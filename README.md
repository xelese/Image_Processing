Version: 3.0

----------------------------------------------------------------------------------------------------

CITATION:

All pictures in this assignment are photographs taken by Ravi Voleti and Sunny Shukla,
or results generated by a program written by Ravi Voleti and Sunny Shukla. Ravi Voleti and
Sunny Shukla retains the ownership of these photographs and prohibits any use or modification by
others. The images "rvnature.jpg" and "rvnature2.jpg" provided in the "input" folder must not be
used outside the project. These images are taken by Ravi Voleti, and no one except Sunny Shukla
can use these images outside the project.

----------------------------------------------------------------------------------------------------

NOTE:

The text files in "input" folder doesn't contain any relative path and will be useless to be used
instead of on Ravi Voleti's system. These files are used to test all the image commands in simulated
environment. The output images generated by executing these files on Ravi Voleti's system
are stored in "res" folder.

----------------------------------------------------------------------------------------------------

HOW TO USE:

I am going to demonstrate the script method of our program using 1. Dither and 2. rainbow Vertical
 as our examples.

1. Create a text file, which contains the script for what the program needs to do. In our case we
create two text files called "ditherDriver.txt" and "rainbowVerticalDriver.txt".

2. Next open ditherDriver.txt and write the following script:
	
        load [path]/[image file]
    
        dither
    
        save [path]/[image file]
        
    In load replace [path/image file] with your image path/image file name.
    This input path and file name in my system is.
    
        /home/ravi/Desktop/rvnature.jpg

    dither command tells the program that we want to filter the image as a dither.

    Similarly, open "rainbowVerticalDriver.txt" and write the following:

            rainbow_vertical [strip size] [height]

            save [path]/[image file]
    
    rainbow_vertical command lets the program know that you want to generate a vertical
     rainbow.
    
    input the size of each strip in terms of pixels in [strip size] and the height of the
    image in [height].

3. Run the file from a terminal or a command prompt with the ditherDriver.txt
 or rainbowVerticalDriver.txt as an argument for the program, as shown below.

        $ java -jar [jar file name].jar -script [Path]/[script file name]
        
        $ java -jar A9.jar -script /home/ravi/Desktop/ditherDriver.txt

        $ java -jar A9.jar -script /home/ravi/Desktop/rainbowVerticalDriver.txt

4. You will notice that the an image will be generated with its respective operation in the save
    path.

5. Alternatively if you want to use the GUI write the following in the terminal:

        $ java -jar [jar file name].jar -interactive
    
    a. This will open a GUI where you can access the image operation through the tools menu.
    
    b. To load an image in the GUI click:
           
            File -> load
    
    c. This will open a dialog box where you can find and select an image file.
    
    d. Use the tools menu to apply image operations or generate an image.
    
            Tools -> Generate Flags
                  -> Generate Image
                  -> Image operations
    
    e. To save an image click:
        
            File -> save
            
    d. To quit click:
            
            File -> quit
            or
            click the cross on the title bar.
            

NOTE: We have checked the above execution of jar file on Ubuntu 16.04 LTS and Ubuntu 19.04.

Commands List for script or default run:

    COMMAND			 DESCRIPTION				ARGUMENTS
    "quit"			 quit the program.			No arguments.
    "load"			 load an image.				<path/image name>
    "save"			 save the image.			<path/image name>
    "checkerboard"		 create acheckerboard pattern.		<size of square>
    "rainbow_vertical"       create a vertical rainbow.		<strip size> <height>
    "rainbow_horizontal"     create a horizontal rainbow.           <strip size> <width>
    "blur"			 blur the loaded image.                 No arguments.
    "sharpen"	         sharpen the loaded image.              No arguments.
    "greyscale"	         apply greyscale on the loaded image.   No arguments.
    "sepia"			 apply sepia on the loaded image.       No arguments.
    "france"	         generate a flag of France.             <number of pixels>
    "swiss"			 generate a flag of Switzerland.        <number of pixels>
    "greece"		 generate a flag if greece.             <number of pixels>
    "mosaic"		 apply mosaic on the loaded image.      No arguments.
    "dither"		 apply dither on the loaded image.      No arguments.

NOTE: dither, mosaic, blur, sharpen, sepia and greyscale require you to load the image before using
the command in both script and GUI.


----------------------------------------------------------------------------------------------------

DESIGN CHANGES:

From Version 2.0 to Version 3.0, the overall design is the same, i.e. same as an MVC framework.
However, in Version 3.0, the Features functionality has been added to the controller, this 
functionality helps the controller to interact with interactive components like views, scripts, etc
in an MVC framework. Also, the controller functionality has been abstracted and used with several
types of controller to execute the program in different modes like script mode and interactive mode. 

----------------------------------------------------------------------------------------------------

OVERALL FLOW:

1. Driver instantiate image controller with the input mode from the user. A controller will
either run in a CLI (Command Line Interface) mode, in a Script mode or in a GUI (Graphical User
Interface) mode. This is determined by the input mode selected by the user, i.e. either 
"-script" or "-interactive" or "-cli". But for this project only "-script" and "-interactive" mode
are considered as valid modes. CLI Mode is the legacy code and hence preserved as it is.
2. In SCRIPT mode a script passed which contains list of commands to be processed one by one. 
3. In GUI mode a view diplayed with which the user will interact using different menus and
pop-up boxes.
4. Driver calls "process" method of the image controller instance.
5. In SCRIPT mode the image controller read the commands from the script one line at a time.
6. In GUI mode the image controller wait for the commands to be received from the view.
4. Image controller internally parses the user inputs depending on the image operations chosen by
the user, and selects an appropriate command to be executed.
5. Image controller executes the command with required inputs.
6. Image controller return true if all the commands are executes successfully, else throws an error.
7. Driver exits if user explicitly have mentioned the quit command from the GUI or if the image
controller is unable to find any more line to process in the script.

----------------------------------------------------------------------------------------------------

MODELS:

Generating Image:

A. CheckerBoard.
1. The checkerboard takes the size of the square as user input.
2. If the user input is greater than zero, the method creates a blank image canvas of
size 8 x 8 times the size of each square.
3. Then we run over each and every pixel set the color of the square
as black if it's an odd square, or else the pixels are colored as white.
4. The input in this can be as small as 1 pixel.

----------------------------------------------------------------------------------------------------

B. Rainbow.

1. Rainbow can be of two types Vertical or horizontal. We have made a class each for execution.
They take two parameters as input:
    - The size of each strip. 
    - The length/width of the image.
2. We generate a blank canvas as width/height = 7x strip size and
the other dimension as provided above.
3. Additionally, we, have created a rainbow array with 7 colors Violet,
Indigo, Blue, Green, Yellow, Orange, and Red.
4. We iterate over each pixel and set the RGB value to the corresponding color.
5. The input of strip size and another dimension (width/height) can be as small as 1 pixel.

----------------------------------------------------------------------------------------------------

C. Flags.

1. There are three types of flags:
    - France
    - Switzerland
    - Greece
2. All of them take the size of the image (number of pixels) as an input from the user.
3. To support the making of flags, we have made a private helper method called
createRectangle(). This private method is provided with an empty buffered image to draw on,
the width of the rectangle, height of the rectangle, position of x to start from and
position of y to start from. This method creates a rectangle by setting
the RGB values pixel by pixel.

- France: 

    1. We first find out the maximum size of the image that can be formed using the given input
    and accordingly divide it in a 2:3 ratio determining the final width and height. 
    2. Next, we draw 3 rectangles based on this width and height with the colors Blue white and red.
    3. The minimum pixel value for the France flag is 5 pixels.

- Switzerland:

    1. Switzerland flag is a square with its cross being in the ratio of 7:6. Since it follows a
    particular ratio the minimum pixels required to build this flag are 32.
    2. According to the input given, we find the closest width and height of the flag. Then we
    create a red rectangle from this calculated width and height.
    3. Next, we create the cross in 5 parts. Individually the cross is made up of 4 rectangles
    and 1 square in between with its width to height ratio as 7:6.
    4. We create the 4 white rectangles which form the top bottom left and right parts of the
    cross and finally create a square in between.

- Greece:

    1. similar to France the flag is divided into 2:3 ratio. Therefore, we find the width and
    height from the given number of pixels.
    2. The flag's height is divided into 9 parts which are alternating strips of blue and white,
    we calculate and draw the lines first.
    3. Next, we draw a blue square on the top left side, followed by two rectangles the size of
    strip width and strip height.
    4. The minimum number of pixels to make such a flag is 25.

----------------------------------------------------------------------------------------------------

Image Filter.

1. There are two types of image filters:
	- Blur
	- Sharpen
2. Regardless of the kernel used the underlying filter operation is common among all of them.
We abstracted its commonality and in Image Filters class and named its method to apply filter().
3. Both of the filters require a Buffered Image file as an input from the user.
4. Depending on the kernel blur or sharpen operation occurs.
5. the image file is read using a buffered image with Image Io class.
6. Then we iterate through each pixel and read the RGB values whose index position is greater
than 0 and is less than the image width or height.
7. Each value of the pixel is read in RGB, multiplied with the kernel value at its corresponding
pixel and finally added to the overall output for each channel of RGB.
8. The calculated value is clamped between 0 and 255 and is set as an RGB value at that
pixel position.
9. For Blur a 3x3 pixel kernel is used as input as given in the assignment.
10. For Sharpen 5x5 pixel kernel is used as input as given in the assignment.
11. Finally, we return the image from this model class.

----------------------------------------------------------------------------------------------------

Image Transformation.

1. There are two types of image transformations:
	- GreyScale
	- Sepia
2. Both of them have the same underlying transformation operation which we have abstracted in
Image Transformation class with a method called apply color transformation().
3. Both the transformations require a Buffered Image file as an input from the user.
4. Similar to filtering operation, there are are two different kernels for greyscale and sepia.
The effect required is dependent on this kernel. 
5. We iterate through each pixel and read the RGB value whose index position is greater than 0
and l is less than the image width or height.
6. We read the pixel value in RGB and multiply the kernel according to the matrix given in
greyscale and sepia tone in the assignment.
7. Finally, the calculated value is clamped between 0 and 255 and is set as an RGB value at
that pixel position.
8. We return the image from this model class.

----------------------------------------------------------------------------------------------------

DITHERING:

1. We first convert the image to a greyscale image.
2. Now, for every position of row ,column we check for the red component of the pixel. Calcualte
the new color and clamp it to 0 to 255 whichever is closer. Set the value of this new color at
row, column pixel.
3. Calculate error as old color - new color.
4. add error to pixel on the right, on the next row left, below and next row right.
5. We return this new image formed as an immutable image data.

----------------------------------------------------------------------------------------------------

MOSAIC:

1. We choose a number of seeds as a random value.
2. Based on the number seed we choose random row and column pixels on the input image.
3. Now iterating through each pixel of the image we find the distance of each pixel with each
random seed. Then assign the the closest seed to every pixel.
4. Sort all the pixels in the order of seeds and calculate the average of each set.
5. Set the average color for each set.

----------------------------------------------------------------------------------------------------

VIEW:

1. There is a single interface Views, which enforces all the methods a view must override. The Views
interface enforces methods needed to interact with the controller on its implementations.
2. The "display" method should be called when a view is to be displayed to the user.
3. View also register features of the controller which it is interacting, using the
"register" method.
4. It receives the updated image data on successful processing of the command it sent to the
controller, in the "updateData" method.
5. It receives an error event if there is a failure in processing the command it sent to the
controller, in the "errorEvent" method.
6. A view must use the "runCommand" method of the controller's feature to send commands to the
controller.

----------------------------------------------------------------------------------------------------

FEATURES:

1. There is a single interface Features, which enforces all the methods a feature object of a
controller must provide to interact with the interactive components like views, scripts, etc in an
MVC framework.
2. A view must be registered with the features of the controller before the controller starts 
processing using the "register" method.
3. A view will run in a user interactive mode and hence whenever a view requests a image operation
command, it is send to the controller via the FeatureBasics (interface) implementation. 
4. The Features' implementation also provide two methods "updateData" and "errorEvent" to update
data or send error events generated by the controller while executing the command to the 
interactive components of an MVC frameworks like views.
5. A view must use the "runCommand" method of the controller's feature to send commands to the
controller.

----------------------------------------------------------------------------------------------------

CONTROLLER:

1. All controllers extend the Controller interface. Currently, there are three controllers.
    - "ImageControllerCLI" which takes input from user and execute commands corresponding to
    the user inputs in CLI mode, it's execution is disabled in this project.
    - "ImageControllerScript" which takes a scrip from the user and execute the commands from the
    script in the SCRIPT mode.
    - "ImageControllerGUI" which displays a view to the user and user can interact with the view
    to carry out different image operations.
2. The Controller interface enforces a "process" method on its implementations.
3. Suitable commands selected by the controller as per the user input. These user inputs either
placed in a script or are passed to the controller via a view.
4. The program would then read the commands one line at a time, process it and executes them.
5. Controller executes and return true if it is able to process the command/s successfully.
In case of an error an appropriate exception will be thrown.

----------------------------------------------------------------------------------------------------

COMMANDS:

1. All commands extend the Command interface. Each image operation can be represented as one
individual command.
2. The Command interface enforces only one method "run" on its implementations.
3. A command selects a suitable model or a suitable view or both or none as per the processing
requirements. A command called by the controller depending on the user input.
4. A command if encounters an error in execution throws an IllegalArgumentException.
5. A command once executed successfully returns an ImageData object, which holds either the
generated image buffer, or a processed image buffer.

----------------------------------------------------------------------------------------------------

PARAMETERS:

1. Parameters are of two kinds, input parameters and output parameters. Both type of parameters
required to be validated and hence as of now both the interfaces InputParameters and 
OutputParameters extends the Parameters interface. The Parameter interface only enforces one method
"validate" on all of its implementations. This method is used for parameter validations.
2. Input parameters used for taking user input and providing it to the models for executing
an image operation accordingly.
3. Output parameters take user input and handles the saving functionality of a generated or
modified image data. 

----------------------------------------------------------------------------------------------------
